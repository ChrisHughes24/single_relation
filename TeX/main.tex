\def\paperversiondraft{draft}
\def\paperversionblind{blind}

\ifx\paperversion\paperversionblind
\else
  \def\paperversion{blind}
\fi

% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage{xargs}
\usepackage{todonotes}
\usepackage{xparse}
\usepackage{xifthen, xstring}
\usepackage{ulem}
\usepackage{xspace}
\makeatletter
\font\uwavefont=lasyb10 scaled 652
\DeclareSymbolFontAlphabet{\mathrm}    {operators}
\DeclareSymbolFontAlphabet{\mathnormal}{letters}
\DeclareSymbolFontAlphabet{\mathcal}   {symbols}
\DeclareMathAlphabet      {\mathbf}{OT1}{cmr}{bx}{n}
\DeclareMathAlphabet      {\mathsf}{OT1}{cmss}{m}{n}
\DeclareMathAlphabet      {\mathit}{OT1}{cmr}{m}{it}
\DeclareMathAlphabet      {\mathtt}{OT1}{cmtt}{m}{n}
\newcommand\colorwave[1][blue]{\bgroup\markoverwith{\lower3\p@\hbox{\uwavefont\textcolor{#1}{\char58}}}\ULon}
% \makeatother

% \ifx\paperversion\paperversiondraft
% \newcommand\createtodoauthor[2]{%
% \def\tmpdefault{emptystring}
% \expandafter\newcommand\csname #1\endcsname[2][\tmpdefault]{\def\tmp{##1}\ifthenelse{\equal{\tmp}{\tmpdefault}}
%    {\todo[linecolor=#2!20,backgroundcolor=#2!25,bordercolor=#2,size=\tiny]{\textbf{#1:} ##2}}
%    {\ifthenelse{\equal{##2}{}}{\colorwave[#2]{##1}\xspace}{\todo[linecolor=#2!10,backgroundcolor=#2!25,bordercolor=#2]{\tiny \textbf{#1:} ##2}\colorwave[#2]{##1}}}}}
% \else
% \newcommand\createtodoauthor[2]{%
% \expandafter\newcommand\csname #1\endcsname[2][\@nil]{}}
% \fi


% \createtodoauthor{chris}{red}
% \createtodoauthor{tobias}{blue}
% \createtodoauthor{authorThree}{green}
% \createtodoauthor{authorFour}{orange}
% \createtodoauthor{authorFive}{purple}


%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

% Broaden margins to make room for todo notes
\ifx\paperversion\paperversiondraft
  \paperwidth=\dimexpr \paperwidth + 6cm\relax
  \oddsidemargin=\dimexpr\oddsidemargin + 3cm\relax
  \evensidemargin=\dimexpr\evensidemargin + 3cm\relax
  \marginparwidth=\dimexpr \marginparwidth + 3cm\relax
  \setlength{\marginparwidth}{4cm}
\fi

\usepackage[utf8x]{inputenc}
\usepackage{amssymb}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green

\usepackage{listings}


%%% PACKAGES
\usepackage{inputenc}
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float

\usepackage{textcomp}


% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{upgreek}
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{corol}{Corollary}[theorem]
\theoremstyle{definition}
\newtheorem{lemma}{Lemma}[theorem]
\theoremstyle{definition}
\newtheorem{sublemma}{Lemma}[theorem]
\theoremstyle{definition}
\newtheorem{defn}[theorem]{Definition}
\theoremstyle{definition}
\newtheorem{subdef}{Definition}[theorem]
\newtheorem{exmpl}{Example}[theorem]

\usepackage{hyperref}


%%% END Article customizations

%%% The "real" document content comes below...

\title{M4R}

\begin{document}

\section{Free Group}

The free group is implemented in Lean as the set of reduced words. An element of
the free group over a type $S$ of letters is a list of pairs $S \times \mathbb{Z}$,
the letter and the exponent.
A list if the exponent part of every element of the list is non zero, and
no two adjacent elements of the list have the same letter. The free group is the set of
reduced lists.

Multiplication of elements of the free group is implemented by appending the lists
whilst replacing any adjacent occurrences of $(s, m)$ and $(s, n)$ with $(s, m + n)$, and removing
any occurence of $(s, 0)$. Inversion is given by reversing the list and negating
the exponent part of every pair. The identity is given by the empty list.

\begin{defn}[Length]\label{length}
  The length of a word $w$ in the free group is the sum of the absolute values of the exponent
  parts of each element of the corresponding reduced list.
\end{defn}

\section{HNN Extensions}\label{HNN}

\begin{defn}[HNN Extension]
  Given a group $G$ and subgroups $A$ and $B$ of $G$, and an isomorphism $\phi : A \to B$, we can define
  the \textit{HNN extension} relative to $\phi$ of $G$. Let $\langle t \rangle$ be a multiplicative group isomorphic to
  $\mathbb{Z}$, generated by $t$. The HNN extension is the coproduct
  of $G$ and $\langle t \rangle$ quotiented
  by the normal closure of the set $\{ta t^{-1} \phi(a^{-1}) | a \in A\}$
\end{defn}

\begin{defn}[HNN normal form]\label{HNNnormalform}
  Let $w = g_0t^{k_1}g_1t^{k_2}g_2 \cdots t^{k_n}g_n \in G \ast \langle t \rangle$.
  Then $w$ is in \textit{HNN normal form} if or every $i$, $k_i \ne 0$, $k_i > 0$
  implies $g_i \notin A$ and $k_i < 0$ implies $g_i \notin B$.
\end{defn}

Note that the HNN normal form is not unique, two words $w, v \in G \ast \langle t \rangle$
that are equal after mapping into the HNN extension and both in normal form might not be
equal as elements of $G \ast \langle t \rangle$. However if $w \in G \ast \langle t \rangle $
maps to $1$ in the HNN extension
then the following lemma tells us that the unique HNN normal form for $w$ is $1$.

\begin{theorem}[Britton's Lemma]\label{britton}
  Let $w \in G \ast \langle t \rangle$.
  If $w$ is in HNN normal form then $w$
  and $w$ contains a $t$, then $w \ne 1$
  cite (On Britton's theorem Charles Miller)
\end{theorem}

\begin{corol}\label{genbritton}
  If a word $w$ meets the same conditions as in the statement of Britton's Lemma,
  then $w$ cannot be written as a $t$ free word.
\end{corol}
\textit{Proof of Corollary \ref{genbritton}} Suppose $w = g$ with $g \in G$,
then $g^{-1}w$ also meets the conditions
in Theorem \ref{britton}, and therefore $gw^{-1}\ne 1$, contradicting $w = g$.

The HNN normalization process given a word $w \in G \ast \langle t \rangle$
replaces any occurences of $ta$ with $\phi(a)t$ when $a \in A$, and
any occurance of $t^{-1}b$ with $\phi^{-1}(b)t^{-1}$ when $b \in B$.
Applying this rewriting procedure will always produce a word $w'$ in HNN normal form,
such that $w$ and $w'$ are equal after quotienting by the defining relations
of the HNN extension, $\{ta t^{-1} \phi(a^{-1}) | a \in A\}$.

The HNN normalization process describes an algorithm for deciding
equality if two words $w, v \in G \ast \langle t \rangle$ are equal
after mapping into the HNN extension. You can check is $wv^{-1}$ maps to
$1$ in the HNN extension by applying the rewriting procedure to $wv^{-1}$.
In order to compute this algorithm, it is necessary to also
have an algorithm for checking equality of elements of $G$ and
to be able to check whether an element of $G$ is in either of the subgroups $A$ or $B$,
and to be able to compute $\phi$.

\section{The Proof Certificate}

An element of a group $G$ is equal to $1$ in the quotient by the normal closure
of a relation $r$ if and only if it can be written as a product of conjugates of $r$ and $r^{-1}$.
More precisely, there is a group homomorphism $\textit{Eval} : F(G) \to G$, from the free group
over $G$ into $G$ that sends a basis element of $F(G)$,
$g \in G$ to $grg^{-1} \in G$. The image of this map is exactly the kernel of the quotient map.
Therefore an element $p$ of $F(G)$ such that $\text{Eval}(p) = w$
can be seen as a witness that $w$ is in the kernel of the quotient map.

% The algorithm returns a pair of a normalised word $w'$, and
% $p \in F(G)$ such that \newline $w = \text{Eval}(p) w'$.

\begin{defn}(Eval)
  $\text{Eval}(r)$ is a map $F(G) \to G$, sending a basis element $g \in G$ to $grg^{-1}$.
\end{defn}

\begin{defn}[P functor]
  We define a group structure on this set of pairs.
  For any $g \in G$ define an automorphism $MulFree(g)$ of $F(G)$, by sending a basis
  element $h \in G$ to $gh$. This defines a left action of $G$ on $F(G)$. The group
  structure is given by the semidirect product. Define the group $P(G)$ to be
  \begin{equation}
  P(G) := F(G) \rtimes_{MulFree} G
  \end{equation}
  This group has multiplication given by $(a, b) (a', b') = (a MulFree(b)(a'), bb')$
\end{defn}

\begin{subdef}[lhs and rhs]
We define two group homomorphisms from $P$ into $G$. $\text{rhs}$ is the obvious map sending $(a, b)$ to $b$.
$\text{lhs}$ is the map sending $(a,b)$ to $\text{Eval}(a)b$.
Since $\text{Eval}(a)$ is in the kernel of the quotient map,
for any $p\in P(G)$, $\text{lhs}(p)$ and $\text{rhs}(p)$ are equal in the quotient by $r$.
Therefore an element $p$ of $P(G)$ can be regarded as a certificate of the congruence
$\text{lhs}(p) \equiv \text{rhs}(p) \text{ mod } r$.
\end{subdef}

Because both $\text{lhs}$ and $\text{rhs}$ are group homomorphisms, if $p \in P(G)$ is a certificate
of the congruence $a \equiv b \text{ mod } r$, and $q$ is a certificate of the congruence
$c \equiv d \text{ mod } r$, then $pq$ is a certificate of the congruence $ac \equiv bd \text{ mod } r$.
Similarly $p^{-1}$ is a certificate of the congruence $a^{-1} \equiv b^{-1} \text{ mod } r$.

\begin{subdef}($P$ is functorial).
  Given a homomorphism $f : G \to H$,
  functoriality of the free group gives a natural map $F(f) : F(G) \to F(H)$.
  Define the map $P(f) : P(G) \to P(H)$ to send $(p, b) \in P(G)$ to $(F(f)(p), f(b)) \in P(H)$.
  Given a certificate of the congruence $a \equiv b \text{ mod } r$, this map returns
  a certificate of the congruence $f(a) \equiv f(b) \text{ mod } f(r)$.
\end{subdef}

\begin{subdef}(Trans)
  Given $p,q \in P(G)$ such that $p$ is a certificate of the congruence $a = b \text{ mod } r$,
  and $q$ is a certificate of the congruence $b = c \text{ mod } r$, then it is possible to define
  $\text{Trans}(p,q)$ such that $\text{Trans}(p,q)$ is a certificate of the congruence $a = c \text{ mod } r$.
  If $p = (p_1, p_2)$, and $q = (q_1, q_2)$, then $\text{Trans}(p,q) = (p_1q_1, q_2)$.
\end{subdef}

\begin{subdef}(Refl)
  Given $a \in G$, $(1, a)$ is a certificate of the congruence $a = a \text{ mod } r$. Call
  this $\text{Refl}(a)$.
\end{subdef}

It is also possible to define $\textit{Symm}$, such that $\text{lhs}(\text{Symm}(p)) = \text{rhs}(p)$
and vice versa, but this is not used in the algorithm.

\begin{subdef}(ChangeRel)
  Given a certificate $p$ of the congruence $a \equiv b \text{ mod } r$, then it is possible
  to make a certificate of the congruence $a \equiv b \text{ mod } g r g^{-1}$ for any $g \in G$.
  Let for any $g \in G$ let $\phi(g) : F(G) \to F(G)$ be the map sending $h \in G$ to
  $hg$. The $\text{ChangeRel}(g,(p_1,p_2))$ is defined to be $(\phi(g)(p_1), p_2)$ for
  $g \in G$ and $(p_1, p_2) \in P(G)$.
\end{subdef}

\section{Magnus' Method}

We describe an algorithm to check whether an element $w$ of a one relator group is
in the subgroup generated by a set of letters. It also writes $w$ as an element in terms
as a word using only those letters.

\subsection{Base Case}

The base case is the case where the relation $r$ is of the form $a^n$ with
$n \in \mathbb{Z}$, and $a$ a letter in $S$. It is straightforward to decide
the word problem in this group, since $F(S) / a^n$ is isomorphic
to the binary coproduct of $F(S \backslash \{a\})$ and $\mathbb{Z}/n\mathbb{Z}$.

\subsection{Case 1: Letter with exponent sum zero}\label{expsumzero}
There are two cases to consider, the first case is when there is a letter $t$
with exponent sum equal to zero in $r$.

For this case apply the map $\text{AddSubscripts}(t)$ (Definition \ref{AddSubscripts}) to $r$.
Since the exponent sum of $t$ is equal to zero, $\text{AddSubscripts}(t)(r)$ is
of the form $(r', 0_\mathbb{Z})$.
The length (Definition \ref{length}) of the relation $r' \in F(S \times \mathbb{Z})$
is less then the length of $r$.
If $t \notin T$ and the exponent sum of $t$ in $w$ is not zero, then $w$ can not be
written as a word using letters in $T$. If $t \in T$, then $w$ can be written in the
form $w' t^n$ where $t$ has exponent sum zero in $w'$, and $w'$ is a word in $T$ if
and only if $w$ is a word in $T$.

A naive approach would be to apply $\text{AddSubscripts}(t)$ to $w'$, and solve the word
problem in $F(S \times \mathbb{Z})$ with respect to $r'$. However, this approach does not work
because the image of the normal closure of $r'$ under $\text{AddSubscripts}(t)$ restricted
to $F(S \times \mathbb{Z})$ is not the normal closure of $r'$, it is the normal closure of
the set of all relations of the form $\text{ChangeSubscript(n)(r')}$ for every $n$.

We can assume $r$ is \textit{cyclically reduced} (ref Freiheitsatz), meaning the first and last
letter of $r$ are different, and conjugate $r$ if this is not the case.

Pick $x \in S$ such that $x \ne t$ and if $t \in T$ then $x \notin T$. $x$ must also
be a letter in $r$. We can assume that the first letter of $r$ is
$x$, since if it is not it can be $r$ can be conjugated until the first letter is $x$.
Let $a$ and $b$ be respectively the
smallest and greatest subscript of $x$ in $r'$. Let $S'$ be the set
$\{i \in S \backslash \{t\} \times \mathbb{Z} \ | \ i \ne x \vee a \le i \le b \}$.

Define two subsets of $S'$, $A := S' \backslash \{x_b\}$, and $B := S' \backslash \{x_a\}$.
Then there is an isomorphism $\phi$ between these two subgroups given by $\text{ChangeSubscript}(1)$.
The group $F(S) / r$ is isomorphic to the HNN extension of $F(S') / r'$ relative to $\phi$.

The isomorphism $\alpha$ from $F(S)$ to the HNN extension sends a letter
$s \in S \backslash \{t\}$ to $s_0$ and
the letter $t$ to the stable letter $t$ of the HNN extension. Since $t s_i t^{-1} = s_{i+1}$ in
the HNN extension for $s_i \in S'$, $r$ is sent to $r' = 1$ by this map so $\alpha$ is well defined
on the quotient.

$\beta$ sends $s_i \in S'$ to $t^{i} s t^{-i}$ and the stable letter $t$ to $t$.
Again, $r'$ is sent to $r$ by $\beta$, and $\beta (t s_i t^{-1}) = t^{i+1} s t^{-(i+1)} =
\beta (\phi (s_i))$ so $\beta$ preserves the defining relations of the HNN extension and it
is well defined. It can be checked $\beta$ is a two sided inverse to $\alpha$ and so $\alpha$
is an isomorphism.

We then apply the HNN normalization procedure, described in detail in Section \ref{HNNnorm}.
We chose $x$ and $t$ such that either $x \notin T$ or $t \notin T$. In either case if $w$
can be written as a word in $T$, then an HNN normal form of $w$ will be of the form $g t^n$
with $g \in F(S') / r'$. In the case $x \notin T$, then because any word in
$F(S')$ not containing $x_i$ must be in $A \cap B$, there can be no occurence of
$tg$ with $g \notin A$ or $t^{-1}g$
If $t \notin T$, then it must be possible to write $w$ without $t$, so in fact it can be normalized
to $g \in F(S') / r'$. We can check whether any words in $F(S') / r'$ are in the subgroups
generated by $A$ or $B$ using
Magnus' method again for the shorter relation $r'$, and rewrite these words using the letters
in $A$ or $B$ when possible.

Once in the form $g t^n$ with $g \in F(S') / r'$, it is enough to check that
$\text{RemoveSubscript}(g)$ can be written as a word in $T$.
If $t \in T$ then this amounts to solving the word problem for $r'$
and the set $T' := \{ s_i \in S' | s \in T, i \in \mathbb{Z} \}$. If $t \notin T$,
this amounts to checking that $n = 0$ and solving the word problem for
$r'$ and the set $T' := \{s_0 \in S' | s \in T\}$.

\subsection{Case 2: No Letter with exponent sum zero}

If there is no letter $t$ in $r$ with exponent sum zero, then choose $y$
and $t$ such $y \ne t$ and such that if $t \notin T$ then $y \notin T$.
Let $\alpha$ be the exponent sum
of $t$ in $r$, and $\beta$ the exponent sum of $y$.

Then define the map $\psi$ on $F(S)$ defined for $s \in S$ by

\begin{equation}
  \psi(s) =
  \begin{cases}
     t^\beta & \text{if }s = t \\
     yt^{-\alpha} &\text{if } s = y \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

The map $\psi$ can be descended to a map $\bar{\psi} : F(S) / r$ to $F(s) / \psi(r)$. The map
$\psi$ is equal to $\psi_1 \circ \psi_2$,
where $\psi_2$ and $\psi_1$ are defined as follows.

\begin{equation}
  \psi_1(s) =
  \begin{cases}
     yt^{-\alpha} &\text{if } s = y \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

\begin{equation}
  \psi_2(s) =
  \begin{cases}
     t^\beta & \text{if } s = t \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

$\bar{\psi_1} : F(S) / r \to F(r) / \psi_1(r)$ is an isomorphism,
the inverse given by sending $y$ to $yt^\alpha$.
$\bar{\psi_2} : F(S) / r$ to $F(r) / \psi_2(r)$
is also injective.
This is proven constructively in Section \ref{powproof}.
So $\bar{\psi} : F(S) / r$ to $F(r) / \psi(r)$ is injective.

The image of the subgroup generated
by $T$ under $\psi$ might not be the subgroup generated by a set of letters, but it is
always contained in the subgroup generated by $T$.
By the Freiheitsatz if $\psi(w)$ can be written
as a word $w'$ using letters in $T$ then this solution is unique.
Therefore, to check if $\psi(w)$ is in the subgroup generated by
$\psi(T)$, you can first write it as a word in $w' \in \langle T \rangle$ if possible,
and then check if $w'$ is in $\psi(T)$.
The exponent sum of $t$ in $\psi(r)$ is $0$, so the problem of checking
if $\psi(w)$ can be written as a word in $T$ can be solved using
the method described in Section \ref{expsumzero}.

If $t \in T$ then the subgroup generated by $\psi(T)$ is generated by
$T' := T \backslash \{t\} \cup t^\beta$. By the Freiheitsatz if $\psi(w)$ can be written
as a word $w'$ using letters in $T$ then this solution is unique. Therefore,
to check if $\psi(w)$ is in the subgroup generated by $T'$, you can first
write it as a word in $w' in T$ if possible, and then check that for every
occurence of $t^k$ in $w'$, $k$ is a multiple of $\alpha$.

If $t \notin T$, then the subgroup generated by $\psi(T)$ is $T$.

\subsection{Adding and Removing Subscripts}

Given a letter $t$ in the free group over a set $S$, we can define a map into a
semidirect product.

\begin{defn}[ChangeSubscript]\label{changesubscript}
  Define a homomorphism \textit{ChangeSubscript} from $\mathbb{Z}$ to the automorphism
  group of $F(S \times \mathbb{Z})$. If $(x, n) \in S \times mathbb{Z}$ is a basis
  element of the free group, then $\text{AddBasis}(m)(x, n) = (x, m + n)$.
\end{defn}

\begin{defn}[AddSubscripts]\label{AddSubscripts}
  There is a homomorphism $AddSubscripts(t)$ from $F(S)$ into $F(S \times \mathbb{Z})
  \rtimes_{\text{ChangeSubscript}} \mathbb{Z}$ sending a basis element $s \in S$ to
  $(s, 0) \in F(S \times \mathbb{Z})$, when $s \ne t$ and sending $t$ to
  $(1, 1_\mathbb{Z}) \in F(S \times \mathbb{Z}) \rtimes \mathbb{Z}$. Loosely, this map
  replace occurence of $t^n a t^{-n}$ with $a_t$
\end{defn}

The map \textit{AddSubscripts} is only used during the algorithm on words $w$ when the sum of the
exponents of $t$ in $w$ is zero, meaning the result will always be of the form
$(w', 0_{\mathbb{Z}})$.

\begin{defn}[RemoveSubscripts]
  \textit{RemoveSubscripts} send a basis element of $F(S\times \mathbb{Z})$,  $(s, n) \in S\times \mathbb{Z}$
  to $t^n s t^{-n}$.
\end{defn}
\textit{RemoveSubscripts} is a group homomorphism and if $r$ is a word such that
of $\text{Addsubscripts}(r)$ is of the form $(r', 0_\mathbb{Z})$,
then $\text{RemoveSubscripts}(r')=r$.

% \subsection{Base Case}\label{BaseCase}

% The base case is the case where the relation $r$ is of the form $a^n$ with
% $n \in \mathbb{Z}$, and $a$ a letter in $S$. It is straightforward to decide
% the word problem in this group, since $F(S) / a^n$ is isomorphic
% to the binary coproduct of $F(S \backslash \{a\})$ and $\mathbb{Z}/n\mathbb{Z}$.
% However computing the appropriate proof term requires some explanation.

% To compute the proof term, we write a function that takes an unnormalized word
% $w \in F(S)$, and a normalized proof word with proof $p \in P(F(S))$, and returns
% a word $q \in P(F(S))$, such that $\text{lhs}(q) = w\text{lhs}(p)$ and
% $\text{rhs}(q)$ is a normalization of $w \text{rhs}(p)$. By normalized,
% we mean that there is no occurence of $a^k$ where $k \ne 0$ is a multiple of $n$.

% We can normalize the word $a^k$ where $k$ is a multiple of $n$ to
% $([1]^(n / k), 1) \in P(F(S))$, where $[1] \in F(F(S))$, is the basis element
% corresponding to $1 \in F(S)$.

% \begin{defn}(BaseCaseCore)
%   $\text{BaseCaseCore}(w, p)$ is defined by recursion on the list representation of $w$.
%   If $w = 1$, then return $p$. If $\text{rhs}(p) = 1$ then,
% \end{defn}

\subsection{HNN normalization}\label{HNNnorm}

We first present a simplified version of the HNN normalization that does not compute
the proof certificates, and then explain how to compute the certficates at the
same time as normalization.

To compute the HNN normalized term,
first compute the following isomorphism from $F(S)$ into the binary
coproduct $F(S') \ast \langle t' \rangle$. $\langle t' \rangle$ is a cyclic
multiplicative group isomorphic to $\mathbb{Z}$ and generated by $t'$.

\begin{defn}\label{tocoprod}
  Define a map on a basis element $i$ as follows
  \begin{equation}
    \begin{cases}
      i_0 \in S' & i \ne t \\
      t' & i = t
    \end{cases}
  \end{equation}
\end{defn}

It is important that $a \le 0 \le b$, to ensure that this map does map into
$F(S' \times \langle t' \rangle)$.

Then apply the HNN normalization procedure. For this particular HNN extension
$\phi$ is \textit{ChangeSubscript} %% (Definition \ref{changesubscript}).
For each occurence of $t'w$, we can use \textit{Solve} to check whether $w$ is equal
to a word  $a \in A$ in the quotient $F(S') / r'$, and if it is equal to some word $a$, rewrite
$t'w$ to $\text{Changesubscript}(1)(a)t'$. Similarly, For each occurence of
$wt'^{-1}$, use \textit{Solve}
to check whether $w$ is equal to a word $b \in B$ in the quotient
$F(S') / r'$, and if it it equal to
some word $b$ rewrite $t'^{-1}$ to $\text{ChangeSubscript}(-1)(b)t'^{-1}$.



% \begin{defn}[HNNNormalizeCore]
% The function \textit{HNNNormalizeCore} takes an unnormalized word $w$ and a normalized word $v$
% both in the binary coproduct. It will return an HNN normalized word $vw$. It is defined by cases.
% When $w = 1$, it returns $v$. When $w = gw'$ for some $g \in F(S')$ and $v = 1$, then it returns

%   \begin{equation}
%       \text{HNNNormalizeCore}(v, w) = \\
%       \begin{cases}
%         v & \text{if } w=1 \\
%         \text{HNNNormalizeCore}(n, w') & \text{if } w = gw' \text{ for some } g \text{ and } v = 1 \\
%         \text{HNNNormalizeCore}(vg, w') & \text{if } w = gw' \text{ for some } g \in F(S') \\
%         \text{HNNNormalizeCore}(v' \text{ChangeSubscript(k, {Solve}(a, A), w')) \text{if } w = aw'
%           \text{ for some } a \in A
%       \end{cases}
%   \end{equation}
% \end{defn}

\subsubsection{Computing Proof Certificates}\label{HNNPC}

To compute proof certificates a slightly modification of the procedure described in Section
\ref{HNNnorm} is used.

First define a modification of Definition \ref{tocoprod}, from $F(S)$ into the binary
coproduct $P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$.

\begin{defn}\label{tocoprodP}
  Define a map on the basis as follows
  \begin{equation}
    \begin{cases}
      \text{Refl}(i, t'^0) \in F(S' \times \langle t' \rangle) & i \in S \text{ and } i \ne t \\
      t' & i = t
    \end{cases}
  \end{equation}
\end{defn}

There is also a map $Z$ from $P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$ into
$P(F(S))$. This map is not computed as part of the algorithm, but is useful to define anyway.

\begin{defn}
  The map $Z$ sends $t' \in \langle t' \rangle$ to $\text{Refl}(t) \in P(F(S))$.
  It sends $p \in P(F(S \times \mathbb{Z}))$ to $P(\text{RemoveSubscripts})(p) \in P(F(S))$
\end{defn}

The aim is to define a normalization process into that turns a word $w \in F(S)$ into
word $n \in P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$,
such that after applying \textit{rhs}, the same word is returned as in the
normalization process described in Section \ref{HNNnorm}. We also want
$\text{lhs}(Z(n))$ to be equal to $w$, so we end up with a certificate that $w$
is equal to some normalized word.

\begin{defn}(conjP)\label{conjP}
  Let $(p, a) \in P(F(S \times \mathbb{Z}))$ and $k \in \mathbb{Z}$.
  Define \textit{ConjP} to map into $P(F(S \times \mathbb{Z}))$
  \begin{equation}
    \text{ConjP}(k, (p, a)) = (\text{MulFree}((t,0)^k, p), \text{ChangeSubscript}(k, a))
  \end{equation}
\end{defn}

\textit{conjP} has the property that $\text{lhs}(Z(\text{conjP}(k, p))) = t^k \text{lhs}(Z(p))t^{-k}$,
and similarly for \textit{rhs}. Note that $\textit{conjP}$ maps into $P(F(S \times \mathbb{Z}))$,
and not $P(F(S'))$, although $\textit{rhs}$ of every word computed
will be in $F(S')$.

The procedure described in Section \ref{HNNnorm}
replaced each occurence of $wt'^{-1}$ with \newline $t'^{-1}\text{ChangeSubscript}(-1)(a)$,
where $a \in A$ was a word equal to $w \in F(S')$ in the quotient
$F(S') / r'$.

To compute the proof certificate suppose there is an occurence of $pt'^{-1}$ with
$p \in P(F(S \times \mathbb{Z}))$. Use \textit{Solve} to check whether $\text{rhs}(p)$ is
equal to a word $a \in A$. Suppose $q \in  P(F(S'))$ is the certificate
of this congruence. Then substitute $pt'^{-1}$ with $t'^{-1}\text{ConjP}(1, \text{Trans}(p, q))$.

Similarly replace for every occurence of $pt'$, with $\text{rhs}(p)$ equal to some word $b \in B$,
and $q$ a certificate of this congruence, replace $pt'$ with $t'\text{ConjP}(-1, \text{Trans}(p, q))$.

\subsubsection{Performance}

The order in which the rewriting rules are applied can have a big effect on the performance
of the algorithm.

\begin{exmpl}\label{ltrbad}
As an example, suppose $r' = {x_1y_1}{x_0y_0}^{-2}$, and
$w = t^n x_1y_1 t y_0^{-1}x_0^{-1}$, where $n > 0$.
Then $S'$ is the set $\{x_0, x_1\} \cup \{y_i | i \in \mathbb{Z}\}$,
$A$ is the subgroup generated by $S' \backslash x_1$ and
$B$ the subgroup generated by $S' \backslash x_0$.
Suppose I first make the substitution $ty_0^{-1}x_0^{-1}$ to $y_1^{-1}x_1^{-1} t$,
then $w$ becomes $t^{n}x_1y_1y_1^{-1}x_1^{-1}t = t^{n+1}$.
This is in HNN normal form.

Now consider trying the HNN normalization process from the left.
For any $m \in \mathbb{Z}$, $(x_1y_1)^m = (x_0y_0)^{2m}$,
so the HNN normalization proces will rewrite $t(x_1y_1)^m to (x_1y_1)^{2m}t$.
Therefore $t^nx_1y_1$ will be rewritten to $(x_1y_1)^{2^n}t^n$.
So $w$ gets rewritten to $(x_1y_1)^{2^n} t^{n+1} y_0^{-1}x_0^{-1}$,
which then will eventually be rewritten to $t^{n+1}$. The maximum length
of $w$ during the normalization process became was greater than $2^n$.
\end{exmpl}

\begin{exmpl}\label{rtlbad}
There are also examples of where starting on the left is more effective.
Suppose $r'$ is the same by $w$ is now equal to
$tx_0t^{-1}(x_0y_0)^2$. Starting on the left by rewriting $t x_0$ to $x_1 t$,
$w$ will be rewritten to $x_1t t^{-1}(x_0y_0)^2 = x_1(x_0y_0)^2$.
This was put into normal form without ever having to rewrite a word in $F(S')$.

Starting on the right is more complicated;
$t^{-1}(x_0y_0)^2$ must first be rewritten
to $t^{-1}x_1y_1$ and then $x_0y_0t^{-1}$.
After this $w$ becomes $tx_0^2 y_0t^{-1}$. This is then
rewritten to $x_1^2 y_1$. Starting on the right required
having to rewrite $(x_0y_0)^2$ to $x_1y_1$, invoking
a recursive call to \textit{Solve}.
\end{exmpl}

Applying one rewrite rule first
might mean that another rewrite is unnecessary, or a call to \textit{Solve} is
given an easier problem. It is therefore important to have sensible heuristics to apply the HNN
normalization rules in a sensible order.

Normalizing left to right was found
to have better performance than normalizing right to left, probably because
the cancellation of $t$'s in Example \ref{rtlbad} is more likely than cancellation
of words in $F(S')$ as in Example \ref{ltrbad}.

\begin{exmpl}\label{lastfirst}
There are occasions when it is impossible that a rewrite might become
easier or unnecessary if other rewrites are applied first. For example
consider a word $twtv$, with $w, v \in F(S')$. Then rewriting $tw$ to
$\phi(a)t$ where $a = w$ in $F(S') / r'$ does not make the second problem
any easier, I will still have to check if $v$ is in $A$. However,
starting with rewriting $tv$ to $\phi(a')t$ with $a' = v$ in $F(S') / r'$,
changes the first problem to $tw\phi(a')$.
Checking $w\phi(a') \in A$ might be an easier problem than checking $w \in A$
and $\phi(a') \in A$, and will never be a harder problem. So in this example
it makes sense to attempt the right hand rewrite first.

Additionally if the
right hand rewrite fails, i.e. $v \notin A$, then it will not be possible to
put the word in the form $gt^n$ with $g \in F(S')$. This means we need not
attempt to normalize the rest of the word since we are only interested in the result of
HNN normalization if the word can be put into the form $gt^n$.
\end{exmpl}

The case in Example \ref{lastfirst} can be generalized.
Consider a word \newline $t^{n_0}w_0 \dots t^{n_{k-2}}w_{k-2}t^{n_{k-1}}w_{k-1}t^{n_{k}}w_{k}t^d$.
If $n_k > 0$ and for every $m > 0$, $\sum_{i=0}^m n_{k - i} \ge 0$ then
in order to put the word in the form $gt^n$ with $g \in F(S')$, then it will definitely
be necessary to check $w_k$ is equal to a word  $a \in A$ in the quotient
$F(S') / r'$ and rewrite $tw_k$ to $\phi(a)t$ so this
rewrite should be attempted first.
There is a similar condition when $n_k < 0$.

Consider a word $t^{n_0}w_0 \dots t^{n_{k-2}}w_{k-2}t^{n_{k-1}}w_{k-1}t^{n_{k}}w_{k}t^d$,
then if $n_i > 0$ and for every $m > 0$, $\sum_{j=i}^m n_j$ is positive and
$i < k$, we say the pair $t^{n_i}w_i$ satisifies Condition 2.
When $t^{n_i}w_i$ satisfies Condition 2,
normalizing this pair first will not make any of the rewrites to the right
of $w_i$ any easier; there will no no cancellation of $t$s,
so this rewrite should be attempted after anything to the right of it.

The exponential behaviour in Example \ref{ltrbad} can be mitigated if the "easiest"
rewrites are attempted first. An approximate measure of how
easy it is to normalize a pair $t^{n_i}w_i$ is to count the number of letters
in $w_i \in F(S')$ that are not the corresponding subgroup, $A$ if $n_i > 0$,
$B$ if $n_i < 0$; the less letters not in $A$ (or $B$ if $n_i < 0$),
the easier the problem is.

\begin{defn}[thingy]
For a pair $t^{n_i}w_i$, where $n_i > 0$ we define $\text{thingy}(n_i, w_i)$ to be the number of
occurences of letters in $w_i$ but not in $A$, if $n_i < 0$ it is the number of occurences
of letters in $w_i$ but not in $B$. The number of occurences to be the sum of the absolute
value of the exponents of these letters.
\end{defn}

The rewrites are applied with the following priority
%% Possibly not quite right - check it
\begin{itemize}
  \item Any pairs $t_nw_n$ satisfying Condition 1
  \item Of the pairs that do not satisfy Condition 2, priority is given
    to the pairs $t^n_iw_i$ with the smallest value of $\text{thingy}(n_i, w_i)$.
  \item Out of the pairs that have the equal least value of $\text{thingy}$,
    then attempt to rewrite the leftmost pair first.
\end{itemize}


% \subsubsection{Proof Lengths}

% It is important to apply the rewriting procedure from left to right. This will usually
% produce shorter proof certificates. Consider normalizing $t'^{-1}wt'vt'^{-1}$ with $w, v \in F(S')$.
% Suppose we normalize right to left.
% $t'v$ is normalized to $pt'$ with $p \in P(F(S \times \mathbb{Z}))$.
% After that substitution the new word $t'^{-1}wp$, with $wp \in P(F(S \times \mathbb{Z}))$.
% Suppose $\text{rhs}(wp)$ is normalized to $q \in P(F(S \times \mathbb{Z}))$.
% Then the final normalized word is $\text{conjP}(1, \text{Trans (wp, q)})t'^{-1}$.

% The proof part of $\text{Trans}(wp, q)$ is $\text{MulFree}(w)(\text{Left}(p))\text{Left}(q)$.

% Normalizing the other way, we first normalize $t'^{-1}w$ to $p_2 t'^{-1}$ with
% $p_2 \in P(F(S \times \mathbb{Z}))$. Then the new word is $p_2vt^{-1}$. Suppose
% $\text{rhs} p_2 v$ is normalized to $q_2 \in P(F(S \times \mathbb{Z}))$.
% Then the final normalized word is $t'^{-1}\text{conjP}(-1, \text{Trans} (p_2v, q_2))$.

% The proof part of $\text{Trans} (p_2v, q)$ is $\text{Left}(p_2)\text{Left}(q)$. There is no
% use of \textit{MulFree} since $\text{Left}(v)=1$. On average using \textit{MulFree}
% will make words longer, and so the left to right normalization produces shorter proofs.
% The left to right normalization was found to produce shorter proofs in practice.

\subsection{Injectivity}\label{powproof}

The correctness of the algorithm relies on the fact that the map $\psi_2$ is an injective map.
Since $\psi_2$ is injective, if $p \in P(F(S))$ is a witness of the congruence
$\psi_2(a) \equiv \psi_2(b) \text{ mod } \psi_2(r)$, then there must exist a certificate
$q$ of the congruence $a = b \text{ mod }r$. The question is how to compute this. The proof
of this congruence relies on the fact that the canonical maps into an amalgamated product
of groups are injective. However this proofs relies on the law of the excluded middle, so
it cannot be translated into an algorithm to compute $q$. (Cite proof of amalgamated product).

Suppose $p \in P(F(S))$ is a witness of the congruence
$\psi_2(a) = \psi_2(b) \text{ mod } \psi_2(r)$. It is not necessarily the case that $k$
is a multiple of $n$ in every occurence of $t^k$ in $p$. For example
$p := ([t][tr^{-1}t^{-1}][t]^{-1}, 1) \in P(F(S))$ is a witness of the congruence
$r = 1$. Both $\text{lhs}(p)$ and $\text{rhs}(p)$ are in the image of
$\psi_2$ for $n = 2$, when $r$ is in the image of $\psi_2$,
but $p$ is not in the image of $P(\psi_2)$. However where there are
occurences of $t$, they are all cancelled after $\text{lhs}$ is applied, in fact
you could remove every occurence of $t$ from $p$ and still have a certificate of the same
congruence.

\begin{defn}
  Given a word $w \in F(S)$, define the set of partial exponent sums of a letter $t \in S$ to
  be the set of exponent sums of all the initial words of $w$. For example, the partial
  exponent sums of $t$ in $t^n a t$ are the exponent sums of $t$ in
  $t^n$, $t^na$ and $t^nat$.
\end{defn}

\begin{defn}
  $h$ is a map $F(S) \to F(S \cup \{t'\})$, where $t'$ is some letter not in $S$.
  $h$ replaces every occurence of $t^k$ with $t'^at^b$ in such a way that $a + n b = k$,
  and every partial exponent sum of $t'$ in $h(w)$ is either not a multiple of $n$,
  or it is zero.
\end{defn}

\begin{defn}
  $\theta$ is a group homomorphism $F(S \cup \{t'\})$. Let $s \in S$. Then
  \begin{equation}
    \theta(s) = \begin{cases}
      t & \text{if } s = t' \\
      t^n & \text{if } s = t \\
      s & otherwise
    \end{cases}
  \end{equation}
\end{defn}

$\theta$ and $h$ satisfy $\theta \circ h = \text{id}$. For any $w$ in $F(S)$,
$\theta(w) = \psi_2(w)$.

\begin{defn}(PowProof)\label{PowProof}
  \textit{PowProof} is a map $F(S) \to F(S)$. $\text{PowProof}(w)$ is defined to be
  $h(w)$, but with every occurence of $t'$ replaced with $1$.
\end{defn}

\begin{theorem}\label{powproof}
  For any $p \in F(F(S))$ if \newline $\text{Eval}(\psi_2(r))(p) = \psi_2(w)$,
  then $\text{Eval}(r)(F(\text{PowProof})(p)) = w$.
\end{theorem}

\begin{sublemma}\label{powproof1}
  Consider $\prod_{i = 1}^a s_i^{k_i}$, as an element of the $F(S \cup \{t'\})$
  with $s_i \in S \cup \{t'\}$ (Note that this is not necessarily a reduced
  word; $k_i$ may be zero and $s_i$ may be equal to $s_{i+1}$).
  Suppose every partial product $\prod_{i=1}^b s_i^{k_i}$,
  with $b \le a$ has the property that if the exponent sum of $t'$ is a multiple
  of $n$, then it is zero. Suppose also that $\prod_{i = 1}^b s_i^{k_i}$ has the
  property that for every occurence of $t'^k$ in the reduced product, $k$ is a multiple of
  $n$. Then the reduced word $\prod_{i = 1}^a s_i^{k_i}$
  can be written without an occurence of $t'$.
\end{sublemma}

\textbf{Proof of Lemma \ref{powproof1}.} $\prod_{i=0}^a s_i^{k_i}$ can be written as a reduced
word $\prod_{i = 1}^{c} u_i^{k'_i}$ such that $k'_i$ is never equal to zero and
$u_i \ne u_{i+1}$ for any $i$. The set of partial products of this
$\prod_{i = 1}^{c} u_i^{k'_i}$ is a subset of the set of partial products of $\prod_{i=1}^a s_i^{k_i}$,
therefore the exponent sum of $t'$ in every partial product of $\prod_{i=1}^a s_i^{k_i}$, is
either $0$ or not a multiple of $n$. However, by assumption every occurence $t'^k$ in
$\prod_{i=0}^a s_i^{k_i}$, $k$, is a multiple of $n$, so the exponent sum of $t'$ in every
partial product is $0$. So $\prod_{i=1}^a s_i^{k_i}$ does not contain $t'$.

\textbf{Proof of Theorem \ref{powproof}} \newline
If $\text{Eval}(\psi_2(r))(p)$ is in the image of $\psi_2$, then
$\text{Eval}(r)(F(h)(p))$ has the property
that for every occurence of $t'^k$, $k$ is a multiple of $n$.
If $p' := F(h)(p)$,
then $\text{Eval}(r)(p')$ can be written as a product of the form in
Lemma \ref{powproof1}.
If $r' = \prod_i u_i^{l_i}$, then to write $\text{Eval}(r)(p')$ in this
form, send $\prod_i \left[\prod_{j = 1}^a s_{ij}^{k_j}\right]
\in P(F(S \cup \{t'\}))$, to
\begin{equation} \label{eq:bigprod}
  \prod_i \left(\left(\prod_{j = 1}^a {s_{ij}}^{k_j}\right) \left(\prod_j u_j^{l_j}\right)
  \left(\prod_{j = 1}^a {s_{i(a - j)}}^{-k_{a - j}}\right)\right)
\end{equation}
If all the nested products in Equation \ref{eq:bigprod} are appended into one long product,
then the product has the form in Lemma \ref{powproof1}. Therefore when the word is reduced
it will not contain $t'$ by Lemma \ref{powproof1}. This means that deleting all occurences of
$t'$ will in $p'$ will not change $\text{Eval}(r)(p')$, and therefore
$\text{Eval}(r)(F(\text{PowProof})(p)) = \text{Eval}(r)(F(h)(p))$.
Applying $\psi_2$ to both sides gives
$\psi_2(\text{Eval}(r)(F(\text{PowProof})(p)) =
  \psi_2(\text{Eval}(r)(F(h)(p))) =
  \theta(\text{Eval}(r)(F(h)(p))) =
  \text{Eval}(\psi_2(r))(p)$.



\end{document}
