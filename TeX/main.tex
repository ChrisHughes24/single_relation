\def\paperversiondraft{draft}
\def\paperversionblind{blind}

\ifx\paperversion\paperversionblind
\else
  \def\paperversion{blind}
\fi

% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage{xargs}
\usepackage{todonotes}
\usepackage{xparse}
\usepackage{xifthen, xstring}
\usepackage{ulem}
\usepackage{xspace}
\makeatletter
\font\uwavefont=lasyb10 scaled 652
\DeclareSymbolFontAlphabet{\mathrm}    {operators}
\DeclareSymbolFontAlphabet{\mathnormal}{letters}
\DeclareSymbolFontAlphabet{\mathcal}   {symbols}
\DeclareMathAlphabet      {\mathbf}{OT1}{cmr}{bx}{n}
\DeclareMathAlphabet      {\mathsf}{OT1}{cmss}{m}{n}
\DeclareMathAlphabet      {\mathit}{OT1}{cmr}{m}{it}
\DeclareMathAlphabet      {\mathtt}{OT1}{cmtt}{m}{n}
\newcommand\colorwave[1][blue]{\bgroup\markoverwith{\lower3\p@\hbox{\uwavefont\textcolor{#1}{\char58}}}\ULon}
% \makeatother

% \ifx\paperversion\paperversiondraft
% \newcommand\createtodoauthor[2]{%
% \def\tmpdefault{emptystring}
% \expandafter\newcommand\csname #1\endcsname[2][\tmpdefault]{\def\tmp{##1}\ifthenelse{\equal{\tmp}{\tmpdefault}}
%    {\todo[linecolor=#2!20,backgroundcolor=#2!25,bordercolor=#2,size=\tiny]{\textbf{#1:} ##2}}
%    {\ifthenelse{\equal{##2}{}}{\colorwave[#2]{##1}\xspace}{\todo[linecolor=#2!10,backgroundcolor=#2!25,bordercolor=#2]{\tiny \textbf{#1:} ##2}\colorwave[#2]{##1}}}}}
% \else
% \newcommand\createtodoauthor[2]{%
% \expandafter\newcommand\csname #1\endcsname[2][\@nil]{}}
% \fi


% \createtodoauthor{chris}{red}
% \createtodoauthor{tobias}{blue}
% \createtodoauthor{authorThree}{green}
% \createtodoauthor{authorFour}{orange}
% \createtodoauthor{authorFive}{purple}


%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

% Broaden margins to make room for todo notes
\ifx\paperversion\paperversiondraft
  \paperwidth=\dimexpr \paperwidth + 6cm\relax
  \oddsidemargin=\dimexpr\oddsidemargin + 3cm\relax
  \evensidemargin=\dimexpr\evensidemargin + 3cm\relax
  \marginparwidth=\dimexpr \marginparwidth + 3cm\relax
  \setlength{\marginparwidth}{4cm}
\fi

\usepackage[utf8x]{inputenc}
\usepackage{amssymb}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green

\usepackage{listings}


%%% PACKAGES
\usepackage{inputenc}
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float

\usepackage{textcomp}


% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{upgreek}
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{corol}{Corollary}[theorem]
\theoremstyle{definition}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{sublemma}{Lemma}[theorem]
\theoremstyle{definition}
\newtheorem{defn}[theorem]{Definition}
\theoremstyle{definition}
\newtheorem{subdef}{Definition}[theorem]

\usepackage{hyperref}


%%% END Article customizations

%%% The "real" document content comes below...

\title{M4R}

\begin{document}

\section{Free Group}

The free group is implemented in Lean as the set of reduced words. An element of
the free group over a type $S$ of letters is a list of pairs $S \times \mathbb{Z}$,
the letter and the exponent.
A list if the exponent part of every element of the list is non zero, and
no two adjacent elements of the list have the same letter. The free group is the set of
reduced lists.

Multiplication of elements of the free group is implemented by appending the lists
whilst replacing any adjacent occurrences of $(s, m)$ and $(s, n)$ with $(s, m + n)$, and removing
any occurence of $(s, 0)$. Inversion is given by reversing the list and negating
the exponent part of every pair. The identity is given by the empty list.

\begin{defn}[Length]\label{length}
  The length of a word $w$ in the free group is the sum of the absolute values of the exponent
  parts of each element of the corresponding reduced list.
\end{defn}

\section{HNN Extensions}\label{HNN}

\begin{defn}[HNN Extension]
  Given a group $G$ and subgroups $A$ and $B$ of $G$, and an isomorphism $\phi : A \to B$, we can define
  the \textit{HNN extension} relative to $\phi$ of $G$. Let $\langle t \rangle$ be a multiplicative group isomorphic to
  $\mathbb{Z}$, generated by $t$. The HNN extension is the coproduct
  of $G$ and $\langle t \rangle$ quotiented
  by the normal closure of the set $\{ta t^{-1} \phi(a^{-1}) | a \in A\}$
\end{defn}

\begin{theorem}[Britton's Lemma]\label{britton}
  Let $w = g_0t^{k_1}g_1t^{k_2}g_2 \cdots t^{k_n}g_n$ be a word in the HNN extension.
  If for every $i$, $k_i \ne 0$, $k_i > 0$ implies $g_i \notin A$ and $k_i < 0$ implies $g_i \notin B$,
  and $w$ contains a $t$, then $w \ne 1$
  cite (On Britton's theorem Charles Miller)
\end{theorem}

\begin{corol}\label{genbritton}
  If a word $w$ meets the same conditions as in the statement of Britton's Lemma,
  then $w$ cannot be written as a $t$ free word.
\end{corol}
\textit{Proof of Corollary \ref{genbritton}} Suppose $w = g$ with $g \in G$, then $g^{-1}w$ also meets the conditions
in Theorem \ref{britton}, and therefore $gw^{-1}\ne 1$, contradicting $w = g$.

The HNN normalization process replaces any occurences of $ta$ with $\phi(a)t$ when $a \in A$, and
any occurance of $t^{-1}b$ with $\phi^{-1}(b)t^{-1}$ when $b \in B$. This produces a word of
the form in Theorem \ref{britton}.

\section{The Proof Certificate}

An element of a group $G$ is equal to $1$ in the quotient by the normal closure
of a relation $r$ if and only if it can be written as a product of conjugates of $r$ and $r^{-1}$.
More precisely, there is a group homomorphism $\textit{Eval} : F(G) \to G$, from the free group
over $G$ into $G$ that sends a basis element of $F(G)$,
$g \in G$ to $grg^{-1} \in G$. The image of this map is exactly the kernel of the quotient map.
Therefore an element $p$ of $F(G)$ such that $\text{Eval}(p) = w$
can be seen as a witness that $w$ is in the kernel of the quotient map.

% The algorithm returns a pair of a normalised word $w'$, and
% $p \in F(G)$ such that \newline $w = \text{Eval}(p) w'$.

\begin{defn}(Eval)
  $\text{Eval}(r)$ is a map $F(G) \to G$, sending a basis element $g \in G$ to $grg^{-1}$.
\end{defn}

\begin{defn}[P functor]
  We define a group structure on this set of pairs.
  For any $g \in G$ define an automorphism $MulFree(g)$ of $F(G)$, by sending a basis
  element $h \in G$ to $gh$. This defines a left action of $G$ on $F(G)$. The group
  structure is given by the semidirect product. Define the group $P(G)$ to be
  \begin{equation}
  P(G) := F(G) \rtimes_{MulFree} G
  \end{equation}
  This group has multiplication given by $(a, b) (a', b') = (a MulFree(b)(a'), bb')$
\end{defn}

\begin{subdef}[lhs and rhs]
We define two group homomorphisms from $P$ into $G$. $\text{rhs}$ is the obvious map sending $(a, b)$ to $b$.
$\text{lhs}$ is the map sending $(a,b)$ to $\text{Eval}(a)b$.
Since $\text{Eval}(a)$ is in the kernel of the quotient map,
for any $p\in P(G)$, $\text{lhs}(p)$ and $\text{rhs}(p)$ are equal in the quotient by $r$.
Therefore an element $p$ of $P(G)$ can be regarded as a certificate of the congruence
$\text{lhs}(p) \equiv \text{rhs}(p) \text{ mod } r$.
\end{subdef}

Because both $\text{lhs}$ and $\text{rhs}$ are group homomorphisms, if $p \in P(G)$ is a certificate
of the congruence $a \equiv b \text{ mod } r$, and $q$ is a certificate of the congruence
$c \equiv d \text{ mod } r$, then $pq$ is a certificate of the congruence $ac \equiv bd \text{ mod } r$.
Similarly $p^{-1}$ is a certificate of the congruence $a^{-1} \equiv b^{-1} \text{ mod } r$.

\begin{subdef}($P$ is functorial).
  Given a homomorphism $f : G \to H$,
  functoriality of the free group gives a natural map $F(f) : F(G) \to F(H)$.
  Define the map $P(f) : P(G) \to P(H)$ to send $(p, b) \in P(G)$ to $(F(f)(p), f(b)) \in P(H)$.
  Given a certificate of the congruence $a \equiv b \text{ mod } r$, this map returns
  a certificate of the congruence $f(a) \equiv f(b) \text{ mod } f(r)$.
\end{subdef}

\begin{subdef}(Trans)
  Given $p,q \in P(G)$ such that $p$ is a certificate of the congruence $a = b \text{ mod } r$,
  and $q$ is a certificate of the congruence $b = c \text{ mod } r$, then it is possible to define
  $\text{Trans}(p,q)$ such that $\text{Trans}(p,q)$ is a certificate of the congruence $a = c \text{ mod } r$.
  If $p = (p_1, p_2)$, and $q = (q_1, q_2)$, then $\text{Trans}(p,q) = (p_1q_1, q_2)$.
\end{subdef}

\begin{subdef}(Refl)
  Given $a \in G$, $(1, a)$ is a certificate of the congruence $a = a \text{ mod } r$. Call
  this $\text{Refl}(a)$.
\end{subdef}

It is also possible to define $\textit{Symm}$, such that $\text{lhs}(\text{Symm}(p)) = \text{rhs}(p)$
and vice versa, but this is not used in the algorithm.

\begin{subdef}(ChangeRel)
  Given a certificate $p$ of the congruence $a \equiv b \text{ mod } r$, then it is possible
  to make a certificate of the congruence $a \equiv b \text{ mod } g r g^{-1}$ for any $g \in G$.
  Let for any $g \in G$ let $\phi(g) : F(G) \to F(G)$ be the map sending $h \in G$ to
  $hg$. The $\text{ChangeRel}(g,(p_1,p_2))$ is defined to be $(\phi(g)(p_1), p_2)$ for
  $g \in G$ and $(p_1, p_2) \in P(G)$.
\end{subdef}

\section{Magnus' Method}

We describe an algorithm to check whether an element $w$ of a one relator group is
in the subgroup generated by a set of letters. It also writes $w$ as an element in terms
as a word using only those letters.

\subsection{Base Case}

The base case is the case where the relation $r$ is of the form $a^n$ with
$n \in \mathbb{Z}$, and $a$ a letter in $S$. It is straightforward to decide
the word problem in this group, since $F(S) / a^n$ is isomorphic
to the binary coproduct of $F(S \backslash \{a\})$ and $\mathbb{Z}/n\mathbb{Z}$.

\subsection{Case 1: Letter with exponent sum zero}\label{expsumzero}
There are two cases to consider, the first case is when there is a letter $t$
with exponent sum equal to zero in $r$.

For this case apply the map $\text{AddSubscripts}(t)$ (Definition \ref{AddSubscripts}) to $r$.
Since the exponent sum of $t$ is equal to zero, $\text{AddSubscripts}(t)(r)$ is
of the form $(r', 0_\mathbb{Z})$.
The length (Definition \ref{length}) of the relation $r' \in F(S \times \mathbb{Z})$
is less then the length of $r$.
If $t \notin T$ and the exponent sum of $t$ in $w$ is not zero, then $w$ can not be
written as a word using letters in $T$. If $t \in T$, then $w$ can be written in the
form $w' t^n$ where $t$ has exponent sum zero in $w'$, and $w'$ is a word in $T$ if
and only if $w$ is a word in $T$.

A naive approach would be to apply $\text{AddSubscripts}(t)$ to $w'$, and solve the word
problem in $F(S \times \mathbb{Z})$ with respect to $r'$. However, this approach does not work
because the image of the normal closure of $r'$ under $\text{AddSubscripts}(t)$ restricted
to $F(S \times \mathbb{Z})$ is not the normal closure of $r'$, it is the normal closure of
the set of all relations of the form $\text{ChangeSubscript(n)(r')}$ for every $n$.

Pick $x \in S$ such that $x \ne t$ and if $t \in T$ then $x \notin T$. $x$ must also
be a letter in $r$. Cyclically conjugate $r$, so the first letter is $x$.
Let $a$ and $b$ be respectively the
smallest and greatest subscript of $x$ in $r'$. Let $S'$ be the set
$\{i \in S \backslash \{t\} \times \mathbb{Z} \ | \ i \ne x \vee a \le i \le b \}$.

Define two subsets of $S'$, $A := S' \backslash \{x_b\}$, and $B := S' \backslash \{x_a\}$.
Then there is an isomorphism $\phi$ between these two subgroups given by $\text{ChangeSubscript}(1)$.
The group $F(S) / r$ is isomorphic to the HNN extension of $F(S') / r'$ relative to $\phi$.

The isomorphism $\alpha$ from $F(S)$ to the HNN extension sends a letter
$s \in S \backslash \{t\}$ to $s_0$ and
the letter $t$ to the stable letter $t$ of the HNN extension. Since $t s_i t^{-1} = s_{i+1}$ in
the HNN extension for $s_i \in S'$, $r$ is sent to $r' = 1$ by this map so $\alpha$ is well defined
on the quotient.

$\beta$ sends $s_i \in S'$ to $t^{i} s t^{-i}$ and the stable letter $t$ to $t$.
Again, $r'$ is sent to $r$ by $\beta$, and $\beta (t s_i t^{-1}) = t^{i+1} s t^{-(i+1)} =
\beta (\phi (s_i))$ so $\beta$ preserves the defining relations of the HNN extension and it
is well defined. It can be checked $\beta$ is a two sided inverse to $\alpha$ and so $\alpha$
is an isomorphism.

We then apply the HNN normalization procedure, described in detail in Section \ref{HNNnorm}.
We chose $x$ and $t$ such that either $x \notin T$ or $t \notin T$. In either case if $w$
can be written as a word in $T$, then an HNN normal form of $w$ will be of the form $g t^n$
with $g \in F(S') / r'$. In the case $x \notin T$, then because any word in
$F(S')$ not containing $x_i$ must be in $A \cap B$, it is always possible to push $t$ to the right.
If $t \notin T$, then it must be possible to write $w$ without $t$, so in fact it can be normalized
to $g \in F(S') / r'$. We can check whether any words in $F(S') / r'$ are in the subgroups generated by $A$ or $B$ using
Magnus' method again for the shorter relation $r'$, and rewrite these words using the letters
in $A$ or $B$ when possible.

Once in the form $g t^n$ with $g \in F(S') / r'$, it is enough to check that $g$ can be written
as a word in $T$. If $t \in T$ then this amounts to solving the word problem for $r'$
and the set $T' := \{ s_i \in S' | s \in T, i \in \mathbb{Z} \}$. If $t \notin T$, this amounts to checking
that $n = 0$ and solving the word problem for $r'$ and the set $T' := \{s_0 \in S' | s \in T\}$.

\subsection{Case 2: No Letter with exponent sum zero}

If there is no letter $t$ in $r$ with exponent sum zero, then choose $y$
and $t$ such $y \ne t$ and such that if $y \in T$ but $t \notin T$, then
$y \cup \{t\}$ does not contain every letter in $r$. Let $\alpha$ be the exponent sum
of $t$ in $r$, and $\beta$ the exponent sum of $y$.

Then define the map $\psi$ on $F(S)$ defined for $s \in S$ by

\begin{equation}
  \psi(s) =
  \begin{cases}
     t^\beta & \text{if }s = t \\
     yt^{-\alpha} &\text{if } s = y \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

The map $\psi$ can be descended to a map $F(S) / r$ to $F(s) / \psi(r)$. The map
$\psi$ is equal to $\psi_1 \circ \psi_2$,
where $\psi_2$ and $\psi_1$ are defined as follows.

\begin{equation}
  \psi_1(s) =
  \begin{cases}
     yt^{-\alpha} &\text{if } s = y \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

\begin{equation}
  \psi_2(s) =
  \begin{cases}
     t^\beta & \text{if } s = t \\
     s & \text{otherwise}
  \end{cases}
\end{equation}

$\psi_1$ is an isomorphism as a map $F(S) / r$ to $F(r) / \psi_1(r)$,
the inverse given by sending $y$ to $yt^\alpha$. $\psi_2$
is injective as a map $F(S) / r$ to $F(r) / \psi_2(r)$,
this is proven constructively in Section \ref{powproof}. So $\psi$ is injective as a map
$F(S) / r$ to $F(r) / \psi(r)$.

The exponent sum of $t$ in $\psi(r)$ is $0$, so the problem can be solved using
the method described in Section \ref{expsumzero}. The image of the subgroup generated
by $T$ under $\psi$ might not be the subgroup generated by a set of letters, but it is
contained in such a subgroup.

\subsection{Adding and Removing Subscripts}

Given a letter $t$ in the free group over a set $S$, we can define a map into a
semidirect product.

\begin{defn}[ChangeSubscript]\label{changesubscript}
  Define a homomorphism \textit{ChangeSubscript} from $\mathbb{Z}$ to the automorphism
  group of $F(S \times \mathbb{Z})$. If $(x, n) \in S \times mathbb{Z}$ is a basis
  element of the free group, then $\text{AddBasis}(m)(x, n) = (x, m + n)$.
\end{defn}

\begin{defn}[AddSubscripts]\label{AddSubscripts}
  There is a homomorphism $AddSubscripts(t)$ from $F(S)$ into $F(S \times \mathbb{Z})
  \rtimes_{\text{ChangeSubscript}} \mathbb{Z}$ sending a basis element $s \in S$ to
  $(s, 0) \in F(S \times \mathbb{Z})$, when $s \ne t$ and sending $t$ to
  $(1, 1_\mathbb{Z}) \in F(S \times \mathbb{Z}) \rtimes \mathbb{Z}$. Loosely, this map
  replace occurence of $t^n a t^{-n}$ with $a_t$
\end{defn}

The map \textit{AddSubscripts} is only used during the algorithm on words $w$ when the sum of the
exponents of $t$ in $w$ is zero, meaning the result will always be of the form
$(w', 0_{\mathbb{Z}})$.

\begin{defn}[RemoveSubscripts]
  \textit{RemoveSubscripts} send a basis element of $F(S\times \mathbb{Z})$,  $(s, n) \in S\times \mathbb{Z}$
  to $t^n s t^{-n}$.
\end{defn}
\textit{RemoveSubscripts} is a group homomorphism and if $r$ is a word such that
of $\text{Addsubscripts}(r)$ is of the form $(r', 0_\mathbb{Z})$,
then $\text{RemoveSubscripts}(r')=r$.

\subsection{Base Case}\label{BaseCase}

The base case is the case where the relation $r$ is of the form $a^n$ with
$n \in \mathbb{Z}$, and $a$ a letter in $S$. It is straightforward to decide
the word problem in this group, since $F(S) / a^n$ is isomorphic
to the binary coproduct of $F(S \backslash \{a\})$ and $\mathbb{Z}/n\mathbb{Z}$.
However computing the appropriate proof term requires some explanation.

To compute the proof term, we write a function that takes an unnormalized word
$w \in F(S)$, and a normalized proof word with proof $p \in P(F(S))$, and returns
a word $q \in P(F(S))$, such that $\text{lhs}(q) = w\text{lhs}(p)$ and
$\text{rhs}(q)$ is a normalization of $w \text{rhs}(p)$. By normalized,
we mean that there is no occurence of $a^k$ where $k \ne 0$ is a multiple of $n$.

We can normalize the word $a^k$ where $k$ is a multiple of $n$ to
$([1]^(n / k), 1) \in P(F(S))$, where $[1] \in F(F(S))$, is the basis element
corresponding to $1 \in F(S)$.

% \begin{defn}(BaseCaseCore)
%   $\text{BaseCaseCore}(w, p)$ is defined by recursion on the list representation of $w$.
%   If $w = 1$, then return $p$. If $\text{rhs}(p) = 1$ then,
% \end{defn}

\subsection{HNN normalization}\label{HNNnorm}

We first present a simplified version of the HNN normalization that does not compute
the proof certificates, and then explain how to compute the certficates at the same time as normalization.

To compute the HNN normalized term, first compute the following isomorphism from $F(S)$ into the binary
coproduct $F(S') \ast \langle t' \rangle$. $\langle t' \rangle$ is a cyclic
multiplicative group isomorphic to $\mathbb{Z}$ and generated by $t'$.

\begin{defn}\label{tocoprod}
  Define a map on a basis element $i$ as follows
  \begin{equation}
    \begin{cases}
      (i, 0) \in F(S') & i \ne t \\
      t' & i = t
    \end{cases}
  \end{equation}
\end{defn}

It is important that $a \le 0 \le b$, to ensure that this map does map into $F(S' \times \langle t' \rangle)$.

Then apply the HNN normalization procedure. For this particular HNN extension
$\phi$ is \textit{ChangeSubscript} %% (Definition \ref{changesubscript}).
For each occurence of
$gt'^{-1}$, we can use \textit{Solve} to check whether $g$ is equal
to a word  $a \in A$ in the quotient $F(S') / r'$, and if it is equal to some word $a$, rewrite
$gt'^{-1}$ to $t'^{-1}\text{Changesubscript}(-1)(a)$. Similarly, For each occurence of $gt'$, use \textit{Solve}
to check whether $g$ is equal to a word $b \in B$ in the quotient $F(S') / r'$, and if it it equal to
some word $b$ rewrite $gt'$ to $t'\text{ChangeSubscript}(1)(b)$.

This is a slight deviation from the procedure decscribed in
Section \ref{HNN}, the rewriting rules are applied in the opposite direction, and therefore
the words are not quite in the normal form described in Theorem \ref{britton}, but are in a reversed
version of this normal form.  The rewriting rules are applied from left to right; wherever a rewriting rule
is applied, everything to the left of where that rule is applied should already be in
HNN normal form. The reasons for these are to generate shorter certificates and are described
in Section \ref{HNNPC}.

% \begin{defn}[HNNNormalizeCore]
% The function \textit{HNNNormalizeCore} takes an unnormalized word $w$ and a normalized word $v$
% both in the binary coproduct. It will return an HNN normalized word $vw$. It is defined by cases.
% When $w = 1$, it returns $v$. When $w = gw'$ for some $g \in F(S')$ and $v = 1$, then it returns

%   \begin{equation}
%       \text{HNNNormalizeCore}(v, w) = \\
%       \begin{cases}
%         v & \text{if } w=1 \\
%         \text{HNNNormalizeCore}(n, w') & \text{if } w = gw' \text{ for some } g \text{ and } v = 1 \\
%         \text{HNNNormalizeCore}(vg, w') & \text{if } w = gw' \text{ for some } g \in F(S') \\
%         \text{HNNNormalizeCore}(v' \text{ChangeSubscript(k, {Solve}(a, A), w')) \text{if } w = aw'
%           \text{ for some } a \in A
%       \end{cases}
%   \end{equation}
% \end{defn}

\subsubsection{Computing Proof Certificates}\label{HNNPC}

To compute proof certificates a slightly modification of the procedure described in Section
\ref{HNNnorm} is used.

First define a modification of Definition \ref{tocoprod}, from $F(S)$ into the binary
coproduct $P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$.

\begin{defn}\label{tocoprodP}
  Define a map on the basis as follows
  \begin{equation}
    \begin{cases}
      \text{Refl}(i, t'^0) \in F(S' \times \langle t' \rangle) & i \in S \text{ and } i \ne t \\
      t' & i = t
    \end{cases}
  \end{equation}
\end{defn}

There is also a map $Z$ from $P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$ into
$P(F(S))$. This map is not computed as part of the algorithm, but is useful to define anyway.

\begin{defn}
  The map $Z$ sends $t' \in \langle t' \rangle$ to $\text{Refl}(t) \in P(F(S))$.
  It sends $p \in P(F(S \times \mathbb{Z}))$ to $P(\text{RemoveSubscripts})(p) \in P(F(S))$
\end{defn}

The aim is to define a normalization process into that turns a word $w \in F(S)$ into
word $n \in P(F(S \times \mathbb{Z})) \ast \langle t' \rangle$,
such that after applying \textit{rhs}, the same word is returned as in the
normalization process described in Section \ref{HNNnorm}. We also want
$\text{lhs}(Z(n))$ to be equal to $w$, so we end up with a certificate that $w$
is equal to some normalized word.

\begin{defn}(conjP)\label{conjP}
  Let $(p, a) \in P(F(S \times \mathbb{Z}))$ and $k \in \mathbb{Z}$.
  Define \textit{ConjP} to map into $P(F(S \times \mathbb{Z}))$
  \begin{equation}
    \text{ConjP}(k, (p, a)) = (\text{MulFree}((t,0)^k, p), \text{ChangeSubscript}(k, a))
  \end{equation}
\end{defn}

\textit{conjP} has the property that $\text{lhs}(Z(\text{conjP}(k, p))) = t^k \text{lhs}(Z(p))t^{-k}$,
and similarly for \textit{rhs}. Note that $\textit{conjP}$ maps into $P(F(S \times \mathbb{Z}))$,
and not $P(F(S'))$, although $\textit{rhs}$ of every word computed
will be in $F(S')$.

The procedure described in Section \ref{HNNnorm}
replaced each occurence of $wt'^{-1}$ with \newline $t'^{-1}\text{ChangeSubscript}(-1)(a)$,
where $a \in A$ was a word equal to $w \in F(S')$ in the quotient
$F(S') / r'$.

To compute the proof certificate suppose there is an occurence of $pt'^{-1}$ with
$p \in P(F(S \times \mathbb{Z}))$. Use \textit{Solve} to check whether $\text{rhs}(p)$ is
equal to a word $a \in A$. Suppose $q \in  P(F(S'))$ is the certificate
of this congruence. Then substitute $pt'^{-1}$ with $t'^{-1}\text{ConjP}(1, \text{Trans}(p, q))$.

Similarly replace for every occurence of $pt'$, with $\text{rhs}(p)$ equal to some word $b \in B$,
and $q$ a certificate of this congruence, replace $pt'$ with $t'\text{ConjP}(-1, \text{Trans}(p, q))$.

\subsubsection{Proof Lengths}

It is important to apply the rewriting procedure from left to right. This will usually
produce shorter proof certificates. Consider normalizing $t'^{-1}wt'vt'^{-1}$ with $w, v \in F(S')$.
Suppose we normalize right to left.
$t'v$ is normalized to $pt'$ with $p \in P(F(S \times \mathbb{Z}))$.
After that substitution the new word $t'^{-1}wp$, with $wp \in P(F(S \times \mathbb{Z}))$.
Suppose $\text{rhs}(wp)$ is normalized to $q \in P(F(S \times \mathbb{Z}))$.
Then the final normalized word is $\text{conjP}(1, \text{Trans (wp, q)})t'^{-1}$.

The proof part of $\text{Trans}(wp, q)$ is $\text{MulFree}(w)(\text{Left}(p))\text{Left}(q)$.

Normalizing the other way, we first normalize $t'^{-1}w$ to $p_2 t'^{-1}$ with
$p_2 \in P(F(S \times \mathbb{Z}))$. Then the new word is $p_2vt^{-1}$. Suppose
$\text{rhs} p_2 v$ is normalized to $q_2 \in P(F(S \times \mathbb{Z}))$.
Then the final normalized word is $t'^{-1}\text{conjP}(-1, \text{Trans} (p_2v, q_2))$.

The proof part of $\text{Trans} (p_2v, q)$ is $\text{Left}(p_2)\text{Left}(q)$. There is no
use of \textit{MulFree} since $\text{Left}(v)=1$. On average using \textit{MulFree}
will make words longer, and so the left to right normalization produces shorter proofs.
The left to right normalization was found to produce shorter proofs in practice.

\subsection{Injectivity}\label{powproof}

The correctness of the algorithm relies on the fact that the map $\psi_2$ is an injective map.
Since $\psi_2$ is injective, if $p \in P(F(S))$ is a witness of the congruence
$\psi_2(a) = \psi_2(b) \text{ mod } \psi_2(r)$, then there must exist a certificate
$q$ of the congruence $a = b \text{ mod }r$. The question is how to compute this. The proof
of this congruence relies on the fact that the canonical maps into an amalgamated product
of groups are injective. However this proofs relies on the law of the excluded middle, so
it cannot be translated into an algorithm to compute $q$. (Cite proof of amalgamated product).

Suppose $p \in P(F(S))$ is a witness of the congruence
$\psi_2(a) = \psi_2(b) \text{ mod } \psi_2(r)$. It is not necessarily the case that $k$
is a multiple of $n$ in every occurence of $t^k$ in $p$. For example
$p := ([t][tr^{-1}t^{-1}][t]^{-1}, 1) \in P(F(S))$ is a witness of the congruence
$r = 1$. Both $\text{lhs}(p)$ and $\text{rhs}(p)$ are in the image of
$\psi_2$ for $n = 2$, when $r$ is in the image of $\psi_2$,
but $p$ is not in the image of $P(\psi_2)$. However where there are
occurences of $t$, they are all cancelled after $\text{lhs}$ is applied, in fact
you could remove every occurence of $t$ from $p$ and still have a certificate of the same
congruence.

\begin{defn}
  Given a word $w \in F(S)$, define the set of partial exponent sums of a letter $t \in S$ to
  be the set of exponent sums of all the initial words of $w$. For example, the partial
  exponent sums of $t$ in $t^n a t$ are the exponent sums of $t$ in
  $t^n$, $t^na$ and $t^nat$.
\end{defn}

\begin{defn}(PowProofAux)
  \textit{PowProofAux} is a map $F(S) \to F(S \cup \{t'\})$, where $t'$ is some letter not in $S$.
  \textit{PowProofAux} replaces every occurence of $t^k$ with $t'^at^b$ in such a way that $a + n b = k$,
  and every partial exponent sum of $t'$ in $\text{PowProofAux}(w)$ is either not a multiple of $n$,
  or it is zero.
\end{defn}

\begin{defn}(PowProof)\label{PowProof}
  \textit{PowProof} is a map $F(S) \to F(S)$. $\text{PowProof}(w)$ is defined to be
  $\text{PowProofAux}(w)$, but with every occurence of $t'$ replaced with $1$.
\end{defn}

\begin{theorem}\label{powproof}
  For any $p \in F(F(S))$ if \newline $\text{Eval}(\psi_2(r))(p) = \psi_2(w)$,
  then $\text{Eval}(r)(F(\text{PowProof})(p)) = w$.
\end{theorem}

\begin{sublemma}\label{powproof1}
  Consider $\prod_{i = 1}^a s_i^{k_i}$, as an element of the $F(S \cup \{t'\})$
  with $s_i \in S \cup \{t'\}$ (Note that this is not necessarily a reduced
  word $k_i$ may be zero and $s_i$ may be equal to $s_{i+1}$).
  Suppose every partial product $\prod_{i=1}^b s_i^{k_i}$,
  with $b \le a$ has the property that if the exponent sum of $t'$ is a multiple
  of $n$, then it is zero. Suppose also that $\prod_{i = 1}^b s_i^{k_i}$ has the
  property that for every occurence of $t'^k$ in the reduced product, $k$ is a multiple of
  $n$. Then the reduced word $\prod_{i = 1}^a s_i^{k_i}$
  can be written without an occurence $t'$.
\end{sublemma}

\textbf{Proof of Lemma \ref{powproof1}.} $\prod_{i=0}^a s_i^{k_i}$ can be written as a reduced
word $\prod_{i = 1}^{c} u_i^{k'_i}$ such that $k'_i$ is never equal to zero and
$u_i \ne u_{i+1}$ for any $i$. The set of partial products of this
$\prod_{i = 1}^{c} u_i^{k'_i}$ is a subset of the set of partial products of $\prod_{i=1}^a s_i^{k_i}$,
therefore the exponent sum of $t'$ in every partial product of $\prod_{i=1}^a s_i^{k_i}$, is
either $0$ or not a multiple of $n$. However, by assumption every occurence $t'^k$ in
$\prod_{i=0}^a s_i^{k_i}$, $k$, is a multiple of $n$, so the exponent sum of $t'$ in every
partial product is $0$. So $\prod_{i=1}^a s_i^{k_i}$ does not contain $t'$.

\textbf{Proof of Theorem \ref{powproof}} \newline
If $\text{Eval}(\psi_2(r))(p)$ is in the image of $\psi_2$, then
$\text{Eval}(r)(\text{PowProofAux}(p))$ has the property
that for every occurence of $t'^k$, $k$ is a multiple of $n$.
If $p' := \text{PowProofAux}(p)$,
then $\text{Eval}(r)(p')$ can be written as a product of the form in
Lemma \ref{powproof1}.
If $r' = \prod_i u_i^{l_i}$, then to write $\text{Eval}(r)(p')$ in this
form, send $\left(\prod_i \left[\prod_{j = 1}^a s_{ij}^{k_j}\right] , \prod_i v_i^{m_i}\right)
\in P(F(S \cup \{t'\}))$, to
\begin{equation} \label{eq:bigprod}
  \left(\prod_i \left(\prod_{j = 1}^a {s_{ij}}^{k_j}\right) \left(\prod_j u_j^{l_j}\right)
  \left(\prod_{j = 1}^a {s_{i(a - j)}}^{-k_{a - j}}\right)\right)\prod_i v_i^{m_i}
\end{equation}
If all the nested products in Equation \ref{eq:bigprod} are appended into one long product,
then the product has the form in Lemma \ref{powproof1}. Therefore when the word is reduced
it will not contain $t'$. This means that deleting all occurences of $t'$ will in
$p'$ will not change $\text{Eval}(r)(p')$, and therefore
$\text{Eval}(r)(PowProof(p)) = \text{Eval}(r)(p')$.

\end{document}
